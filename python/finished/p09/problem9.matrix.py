#!/usr/bin/env python3
from functools import reduce
def matrix_mult(matrix, vector):
    '''
        Right multiply a matrix by a vector
    '''
    product = []
    for row in matrix:
        temp = 0
        for x in range(len(vector)):
            temp += row[x] * vector[x]
        product.append(temp)
    return product

def generate_primitives(vector):
    '''
        generate each of the three primitives generated by a given primitive
        vector and the three special matrices
    '''
    A = [[1, -2, 2], [2, -1, 2], [2, -2, 3]]
    B = [[1, 2, 2], [2, 1, 2], [2, 2, 3]]
    C = [[-1, 2, 2], [-2, 1, 2], [-2, 2, 3]]
    vec_A = matrix_mult(A, vector)
    vec_B = matrix_mult(B, vector)
    vec_C = matrix_mult(C, vector)
    return (vec_A, vec_B, vec_C)

def descendants(root):#max_sum):
    '''
        generates all primitive pythagorean triples less than max_sum

        Other behaviour:
            This function will terminate if the sum of a pythagorean triple
            is max_sum or if a triple is a multiple of max_sum
    '''
    #primitives = []
    #root = [3,4,5]
    max_sum = 1000
    tup = generate_primitives(root)
    for x in tup:
        #print(x)
        print(sum(x))
        if max_sum % sum(x) == 0:
            print("found it")
            return x
        elif sum(x) < max_sum:
            #print(x)
            sol = descendants(x)
            if sol is not None:
                return sol
    return None

val = descendants([3,4,5])
mult = 1000 // sum(val)
print(val, mult)
for i in range(len(val)):
    val[i] = val[i]*mult
print(val)
final = reduce(lambda x, y: x*y, val)
print(final)
